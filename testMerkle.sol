
contract MerkleTreeCreator {

    // The root of the merkle tree, generated by constructTree().
    bytes32 public ROOT;

    // Whether a member has claimed their drop.
    // Note this assumes each members is only eligible for a single drop, i.e.,
    // they occur in the merkle tree only once.
    mapping (address => bool) public hasClaimed;

    function setRoot() public {
        
        (bytes32 root, ) = constructTree();
        ROOT = root;
    }

    function testRoot() public view returns(bool) {

        (, bytes32[][] memory tree) = constructTree();

        bytes32[] memory proof = createProof(0, tree);

        bytes32 leaf = ~keccak256(abi.encode(address(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4), 0));  
        return verify(leaf, proof);
    }

    /**
     1. get the height of tree: members /2 till 1
     2. create nested tree with height
     3. fill up each of the nested arrays. tree[0]: hashed leaves 
     */
    function constructTree() public pure returns (bytes32 root, bytes32[][] memory tree) {
        
        address[] memory members = new address[](4); 
            members[0] = address(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4);
            members[1] = address(1);
            members[2] = address(2);
            members[3] = address(3);
            
        uint256[] memory claimAmounts = new uint256[](4);
            claimAmounts[0] = 0;
            claimAmounts[1] = 1;
            claimAmounts[2] = 2;
            claimAmounts[3] = 3;

        require(members.length > 0 && members.length == claimAmounts.length, "wrong Dims");
       
        // Determine tree height: keep dividing no. of leaves by 2 till you get 1
        uint256 height = 0;
        {
            uint256 n = members.length; // no. of leaves
            while (n != 0) {
                n = n == 1 ? 0 : (n + 1) / 2;   // n+1: cos index starts from 0. 
                ++height;
            }
        }
        tree = new bytes32[][](height);     // 2-D array: bytes32[][height]tree. top-level is height.

        // The first layer of the tree contains the leaf nodes, which are hashes of each member and claim amount.
        bytes32[] memory nodes = tree[0] = new bytes32[](members.length);

        for (uint256 i = 0; i < members.length; ++i) {
            // Leaf hashes are inverted to prevent second preimage attacks.
            nodes[i] = ~keccak256(abi.encode(members[i], claimAmounts[i]));
        }

        // Build up subsequent layers until we arrive at the root hash.
        // Each parent node is the hash of the two children below it.
        // E.g.,
        //              H0         <-- root (layer 2)
        //           /     \
        //        H1        H2
        //      /   \      /  \
        //    L1     L2  L3    L4  <--- leaves (layer 0)
        for (uint256 h = 1; h < height; ++h) {
            
            // calc no.f of hashes for that layer
            uint256 nHashes = (nodes.length + 1) / 2;       // (3+1)/2 = 2 | (4+1)/2 = 2 @audit could be failed cos of this, check again.
            bytes32[] memory hashes = new bytes32[](nHashes);   //bytes32[nHashes] memory hashes -> cre8 array based on number of hashes for that layer
            
            // nodes.length = total no. of members
            for (uint256 i = 0; i < nodes.length; i += 2) {
                
                bytes32 a = nodes[i];

                // Tree is sparse. Missing nodes will have a value of 0.
                bytes32 b = i + 1 < nodes.length ? nodes[i + 1] : bytes32(0);
                // Siblings are always hashed in sorted order.
                hashes[i / 2] = keccak256(a > b ? abi.encode(b, a) : abi.encode(a, b));     //0/2 = 0
            }

            tree[h] = nodes = hashes;
        }
        
        // Note the tree root is at the bottom.
        root = tree[height - 1][0];
    }



    function verify(bytes32 leaf, bytes32[] memory siblings) public view returns (bool) {
        // In a sparse tree, empty leaves have a value of 0, so don't allow 0 as input.
        require(leaf != 0, 'invalid leaf value');  

        bytes32 node = leaf;

        // Siblings are always hashed in sorted order.   
        for (uint256 i = 0; i < siblings.length; ++i){
            node = keccak256(node > siblings[i] ? abi.encode(siblings[i], node) : abi.encode(node, siblings[i]));
        }   
        
        return node == ROOT; 
    }

    // Given a merkle tree and a member index (leaf node index), generate a proof.
    // The proof is simply the list of sibling nodes/hashes leading up to the root.
    function createProof(uint256 memberIndex, bytes32[][] memory tree) public pure returns(bytes32[] memory) {
        
        uint256 height = tree.length;
        uint256 nodeIndex = memberIndex;

        // list of intermediate hashes, less the initial leaf
        bytes32[] memory proof = new bytes32[](height - 1);

        //cycle thru the layers
        for(uint256 h = 0; h < proof.length; ++h){
            // is the index even? if even, look forward, else look backward 
            uint256 sibilingIndex = nodeIndex % 2 == 0 ? nodeIndex + 1 : nodeIndex - 1;

            if(sibilingIndex < tree[h].length){        // will terminate the root
                proof[h] = tree[h][sibilingIndex];
            } 

            nodeIndex /= 2;     // div by 2, rounded down. index for the next layer.
        }

        return proof;
    }

}